00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 4/29/2019 4:36:13 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :Homework 2 Question 3
00000000                             3  * Written by :William Nguyen
00000000                             4  * Date       :4/26/19
00000000                             5  * Description:
00000000                             6  *-----------------------------------------------------------
00000000  =0000A000                  7  INPUT1   EQU $A000
00000000  =0000A001                  8  INPUT2 EQU $A001
00000000  =00006000                  9  Addr1 EQU $00006000
00000000  =00000600                 10  ADDSUM EQU $600
00000000                            11  
00000000                            12  *creating a list from $6000-8000
00000000                            13  *LIST    DC.W    $6000,$6001,$6002
00000000                            14  
00000000  =00006000                 15  ARR     EQU     $6000
00000000                            16  
00000000                            17  
00000000                            18  
00001000                            19      ORG    $1000
00001000                            20  START:                  ; first instruction of program
00001000                            21  
00001000                            22      *Intaking 2 numbers
00001000  103C 0005                 23      MOVE.B  #5,D0           *Trap # 5 in D0
00001004  4E4F                      24      TRAP    #15             *Read a number from the keyboard into D1.L. 
00001006  13C1 0000A000             25      MOVE.B  D1,$A000      
0000100C                            26      
0000100C                            27      *Converting values at $A000 and $A000 (2 individual characters) to hex
0000100C                            28      
0000100C                            29      *check if $A000 and $A001 are 41 - 46
0000100C                            30      
0000100C                            31      *else, assuming proper input, they are 30 - 39
0000100C                            32      
0000100C                            33      **layer check. first for check bottom. then check top (0-9)
0000100C                            34      **if higher than top, check top for A-F
0000100C                            35      
0000100C                            36  CHECK0
0000100C  0C39 0030 0000A000        37      CMP.B   #$30,(INPUT1)           Compares D1 to 30
00001014  6D00 00A8                 38      BLT     INVALID         BLT branches if D1 is less than 30
00001018  0C39 0039 0000A000        39      CMP.B   #$39,(INPUT1)           Compares D1 to 40
00001020  6E00 0006                 40      BGT     CHECK1         BGT branches if D1 is greater than 39
00001024  6000 0012                 41      BRA     SUBNUM0
00001028                            42  
00001028                            43  
00001028                            44  CHECK1
00001028  0C39 0047 0000A000        45      CMP.B   #$47,(INPUT1)           Compares D1 to 47
00001030  6E00 008C                 46      BGT     INVALID         BGT branches if D1 is greater than 46
00001034  6000 000E                 47      BRA     SUBLET0          
00001038                            48  
00001038                            49  SUBNUM0
00001038  0439 0030 0000A000        50      SUBI.B  #$30,INPUT1      Reduce to Binary equiv of 0-9
00001040  6000 000E                 51      BRA STFOR
00001044                            52  
00001044                            53  SUBLET0
00001044  0439 0037 0000A000        54      SUBI.B  #$37,INPUT1      Reduce to Binary equiv of A-F
0000104C  6000 0002                 55      BRA STFOR
00001050                            56  
00001050                            57  
00001050                            58  *byte data stored in memory between the addresses $6000 and $8000 
00001050                            59  *and compare it to the (byte) data at address $A000 
00001050                            60  *(hint: you can consider the memory between $6000 and $8000 an array).
00001050                            61  
00001050                            62  STFOR
00001050  7601                      63      MOVE.L  #1, D3
00001052  283C 000007D0             64      MOVE.L  #2000,D4
00001058  41F8 6000                 65      LEA     ARR,A0
0000105C  43F9 0000A000             66      LEA     INPUT1,A1
00001062  11FC 000A 6010            67      MOVE.B  #$0A,$6010
00001068                            68      
00001068  B803                      69  LOOP    CMP.B   D3,D4
0000106A  6700 0014                 70          BEQ     NEXT
0000106E                            71          *Execute loop code below
0000106E                            72          *compare each byte address to $A000
0000106E                            73          *If the same, store address into Addr1
0000106E  B2D8                      74          CMPA.W   (A0)+,A1
00001070  6700 0006                 75          BEQ     STORE
00001074                            76          
00001074                            77          
00001074  5283                      78          ADDQ.L  #1,D3
00001076  60F0                      79          BRA     LOOP
00001078                            80  
00001078                            81  *store address currently in A0 into Addr1
00001078  21C8 6000                 82  STORE   MOVE.L  A0,Addr1
0000107C  6000 0002                 83          BRA   NEXT
00001080                            84  
00001080                            85  *If no data matches 6000-8000
00001080                            86  *default to Addr1 = $6000
00001080                            87  *Please define a WORD variable called address Addsum. Add a series of bytes stored in the 512 consecutive memory locations beginning at address Addr1, no matter you find the target data or not. Save the sum value into Addsum.
00001080                            88  *There is a chance that the sum might exceed $FFFF, (exceeding the range of word value), so you will also need to store the carry bit if an overflow occurs. Store the carry bit as a BYTE variable called CarryBit.
00001080  7600                      89  NEXT    MOVE.L #0, D3
00001082  283C 00000200             90          MOVE.L #512, D4
00001088  2078 6000                 91          MOVEA.L Addr1,A0
0000108C                            92  
Line 93 ERROR: Invalid addressing mode
0000108C                            93  SUM     ADD.B (A0)+,ADDSUM
0000108C                            94      
0000108C                            95      
0000108C                            96      
0000108C  =0000000D                 97  CR      EQU     $0D         
0000108C  =0000000A                 98  LF      EQU     $0A 
0000108C= 45 6E 74 65 72 20 ...     99  MESSAGE DC.B    'Enter a number: ',0
0000109D= 54 68 61 74 20 69 ...    100  INV     DC.B    'That is not between 30 and 46',CR,LF,0
000010BD                           101  
000010BD                           102  *ADDSUM  DC.W    $600
000010BD                           103  
000010BD                           104  
000010BD= 01                       105  CarryBit DC.B   $01
000010BE  43F8 109D                106  INVALID LEA     INV,A1
000010C2  103C 000E                107          MOVE.B  #14,D0  
000010C6  4E4F                     108          TRAP    #15
000010C8  6000 0002                109          BRA     DONE
000010CC                           110          
000010CC  103C 0009                111  DONE    MOVE.B  #9,D0
000010D0  4E4F                     112          TRAP    #15 
000010D2                           113  
000010D2  FFFF FFFF                114      SIMHALT             ; halt simulator
000010D6                           115      
000010D6                           116  * Put variables and constants here
000010D6                           117  
000010D6                           118      END    START        ; last line of source

1 error detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDR1               6000
ADDSUM              600
ARR                 6000
CARRYBIT            10BD
CHECK0              100C
CHECK1              1028
CR                  D
DONE                10CC
INPUT1              A000
INPUT2              A001
INV                 109D
INVALID             10BE
LF                  A
LOOP                1068
MESSAGE             108C
NEXT                1080
START               1000
STFOR               1050
STORE               1078
SUBLET0             1044
SUBNUM0             1038
SUM                 108C

00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 4/29/2019 2:17:13 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :Homework 2 Question 3
00000000                             3  * Written by :William Nguyen
00000000                             4  * Date       :4/26/19
00000000                             5  * Description:
00000000                             6  *-----------------------------------------------------------
00000000  =0000A000                  7  INPUT1   EQU $A000
00000000  =0000A001                  8  INPUT2 EQU $A001
00000000  =00004000                  9  Addr1 EQU $00004000
00000000                            10  
00000000                            11  *creating a list from $6000-8000
00000000                            12  *LIST    DC.W    $6000,$6001,$6002
00000000                            13  
00000000  =00006000                 14  ARR     EQU     $6000
00000000                            15  
00000000                            16  
00000000                            17  
00001000                            18      ORG    $1000
00001000                            19  START:                  ; first instruction of program
00001000                            20  
00001000                            21      *Intaking 2 numbers
00001000  103C 0005                 22      MOVE.B  #5,D0           *Trap # 5 in D0
00001004  4E4F                      23      TRAP    #15             *Read a number from the keyboard into D1.L. 
00001006  13C1 0000A000             24      MOVE.B  D1,$A000      
0000100C                            25      
0000100C                            26      *Converting values at $A000 and $A000 (2 individual characters) to hex
0000100C                            27      
0000100C                            28      *check if $A000 and $A001 are 41 - 46
0000100C                            29      
0000100C                            30      *else, assuming proper input, they are 30 - 39
0000100C                            31      
0000100C                            32      **layer check. first for check bottom. then check top (0-9)
0000100C                            33      **if higher than top, check top for A-F
0000100C                            34      
0000100C                            35  CHECK0
0000100C  0C39 0030 0000A000        36      CMP.B   #$30,(INPUT1)           Compares D1 to 30
00001014  6D00 0098                 37      BLT     INVALID         BLT branches if D1 is less than 30
00001018  0C39 0039 0000A000        38      CMP.B   #$39,(INPUT1)           Compares D1 to 40
00001020  6E00 0006                 39      BGT     CHECK1         BGT branches if D1 is greater than 39
00001024  6000 0012                 40      BRA     SUBNUM0
00001028                            41  
00001028                            42  
00001028                            43  CHECK1
00001028  0C39 0047 0000A000        44      CMP.B   #$47,(INPUT1)           Compares D1 to 47
00001030  6E00 007C                 45      BGT     INVALID         BGT branches if D1 is greater than 46
00001034  6000 000E                 46      BRA     SUBLET0          
00001038                            47  
00001038                            48  SUBNUM0
00001038  0439 0030 0000A000        49      SUBI.B  #$30,INPUT1      Reduce to Binary equiv of 0-9
00001040  6000 000E                 50      BRA STFOR
00001044                            51  
00001044                            52  SUBLET0
00001044  0439 0037 0000A000        53      SUBI.B  #$37,INPUT1      Reduce to Binary equiv of A-F
0000104C  6000 0002                 54      BRA STFOR
00001050                            55  
00001050                            56  
00001050                            57  *byte data stored in memory between the addresses $6000 and $8000 
00001050                            58  *and compare it to the (byte) data at address $A000 
00001050                            59  *(hint: you can consider the memory between $6000 and $8000 an array).
00001050                            60  
00001050                            61  STFOR
00001050  7601                      62      MOVE.L  #1, D3
00001052  283C 000007D0             63      MOVE.L  #2000,D4
00001058  41F8 6000                 64      LEA     ARR,A0
0000105C  43F9 0000A000             65      LEA     INPUT1,A1
00001062  11FC 000A 6010            66      MOVE.B  #$0A,$6010
00001068                            67      
00001068  B803                      68  LOOP    CMP.B   D3,D4
0000106A  6700 000E                 69          BEQ     NEXT
0000106E                            70          *Execute loop code below
0000106E                            71          *compare each byte address to $A000
0000106E                            72          *If the same, store address into Addr1
0000106E  B2D8                      73          CMPA.W   (A0)+,A1
00001070  6700 0006                 74          BEQ     STORE
00001074                            75          
00001074                            76          
00001074  5283                      77          ADDQ.L  #1, D3
00001076  60F0                      78          BRA     LOOP
00001078                            79  
00001078                            80  *store address currently in A0 into Addr1
00001078  4E71                      81  STORE      NOP   
0000107A                            82  
0000107A                            83  *If no data matches 6000-8000
0000107A                            84  *default to Addr1 = $6000
0000107A  4E71                      85  NEXT       NOP
0000107C                            86  
0000107C  =0000000D                 87  CR      EQU     $0D         
0000107C  =0000000A                 88  LF      EQU     $0A 
0000107C= 45 6E 74 65 72 20 ...     89  MESSAGE DC.B    'Enter a number: ',0
0000108D= 54 68 61 74 20 69 ...     90  INV     DC.B    'That is not between 20 and 25',CR,LF,0
000010AE  43F8 108D                 91  INVALID LEA     INV,A1
000010B2  103C 000E                 92          MOVE.B  #14,D0  
000010B6  4E4F                      93          TRAP    #15
000010B8  6000 0002                 94          BRA     DONE
000010BC                            95          
000010BC  103C 0009                 96  DONE    MOVE.B  #9,D0
000010C0  4E4F                      97          TRAP    #15 
000010C2                            98  
000010C2  FFFF FFFF                 99      SIMHALT             ; halt simulator
000010C6                           100      
000010C6                           101  * Put variables and constants here
000010C6                           102  
000010C6                           103      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDR1               4000
ARR                 6000
CHECK0              100C
CHECK1              1028
CR                  D
DONE                10BC
INPUT1              A000
INPUT2              A001
INV                 108D
INVALID             10AE
LF                  A
LOOP                1068
MESSAGE             107C
NEXT                107A
START               1000
STFOR               1050
STORE               1078
SUBLET0             1044
SUBNUM0             1038
